## Vue vs React 对比

### 一、核心对比表格

| 维度           | Vue（特别是 Vue3）                                  | React（特别是 Hooks/Fiber 架构） |
| -------------- | --------------------------------------------------- | -------------------------------- |
| **设计理念**   | 渐进式框架（MVVM）                                  | 纯视图层库（函数式组件）         |
| **语法结构**   | Options API / Composition API                       | Function Component + Hooks       |
| **模板语法**   | HTML 模板 + 指令（v-if、v-for）                     | JSX（JavaScript XML）            |
| **响应式原理** | Vue2: `Object.defineProperty`<br>Vue3: `Proxy`      | `setState` + immutable 数据流    |
| **状态管理**   | Vuex / Pinia                                        | Redux / Context                  |
| **组件通信**   | props / emits / provide-inject                      | props / Context / Redux          |
| **生命周期**   | created / mounted / updated 等<br>Vue3: `onMounted` | useEffect / useLayoutEffect      |
| **Diff 算法**  | 双端对比 + key + LIS + patchFlag                    | Fiber 架构链表遍历 + 优先级调度  |
| **性能优化**   | 编译时静态提升 / patchFlag 动态标记                 | memo / useCallback / useMemo     |
| **SSR 支持**   | Nuxt.js                                             | Next.js                          |
| **构建工具**   | Vue CLI / Vite                                      | CRA / Vite / Webpack             |
| **生态**       | 官方统一工具链完善                                  | 社区丰富，第三方生态强           |
| **学习曲线**   | 模板语法易上手                                      | 逻辑更灵活，工程化更强           |
| **典型场景**   | 中后台系统 / 大型表单 / CMS                         | WebApp / 跨平台（React Native）  |

### 二、总结话术

> Vue 更适合强调开发效率和响应式交互的项目，Composition API 提升了逻辑复用性；React 更倾向自由组合的函数式架构，Fiber 架构实现了可中断调度机制，更适合构建复杂交互和高并发场景。二者各有优势，应结合业务需求选择。

## Vue3 和 Vue2 的核心区别？

1. 响应式系统实现不同

- `vue2` 使用 `object.defineProerty`,只能劫持已有属性,需手动深度监听(如数组)
- `vue3` 使用 `proxy` 可动态拦截属性添加删除,支持深层次嵌套结构,解决了 Vue2 中属性新增/删除监听不到的问题

2. 新增 Compostion API (组合式 API)

   - `vue2`使用 data(),methods,computed,wathch 等分散配置
   - `vue3`引入 seetup()函数,允许将相关逻辑聚合组织;更易于逻辑复用

3. 生命周期变化
   | Vue2 | vue3 |
   | - | -- |
   | created | setup() |
   | moutend | onMoutend() |
   | beforeDestroy | onBeforeUnmount() |
4. 模板编译和指令处理变化

   - v-if 和 v-for 优先级不同
     - `vue2`:v-for 优先于 v-if
     - `vue3 `:v-if 优先,避免无意义的循环
   - 新增〈script setup>语法糖,减少模板代码冗余

5. 性能优化
   - 默认支持`Tree-shaking`,体积更小
   - 更快的渲染机制(compiler 优化+Proxy)
   - 更好的 TypeScript 支持

> **答题话术**
> “Vue3 的最大变化在于底层响应式由 Object.defineProperty 改为 Proxy，解决了 Vue2 中属性新增/删除-监听不到的问题。同时，它引入了 Composition API，将逻辑更集中管理，更利于复用与类型推导。生命周期也发生变化，统一在 setup() 中调用 onMounted 等函数。我在项目中已经完成从 Vue2 向 Vue3 的升级，整体代码维护性和性能都有显著提升。”

### setup()中为什么不能使用 this?

- `setup()`在整个生命周期中优先级最高,在**组件实例创建之前执行的**，此时组件实例（即 this）尚未被完全初始化;
- `setup()`用于逻辑组织和组合的函数,所有的数据、props、methods 都通过函数参数解构或返回值暴露，**不再依赖 this 上的绑定**。

> **答题话术**
> “因为 setup() 是在组件实例创建之前执行的，因此此时还没有 this 可用。Vue3 推崇函数式逻辑组合方式，因此不再依赖 this，而是通过参数解构和返回对象来使用 props、emit 和响应式数据。这也是 Composition API 更具逻辑复用性和类型推导优势的重要体现。

## Vue2 和 Vue3 响应式的区别

### Vue2(object.defineProerty)

- 遍历递归对象,对每个属性单独设置` getter``setter `,性能开销较大;
- **无法动态监听属性变化(增删)**,对象属性变化时不会触发视图更新，需通过 `Vue.set` 或 `Vue.delete` **手动处理**;
- 无法直接监听数组索引的修改（如 `arr[0] = 1` ）和 `length` 变化;
- 只能支持代理普通对象和数组,不支持 `Map`、`Set` 等复杂数据结构。

### Vue3(Proxy)

- `Proxy` 可以直接代理整个对象，因此可以监听属性的**动态增删**，不再需要手动操作。
- 能够直接监听数组索引的修改（如 `arr[0] = 1` ）以及 `length` 变化。
- 采用懒代理模式,只有在访问属性时才会递归代理子对象,避免了递归遍历的性能开销。
- 支持更多数据结构,除了普通对象数组,`Proxy`还可以代理 `Map`、`Set` 等复杂数据结构。

## Vue2 升级 Vue3 如何实现?遇到的问题,如何解决?

Vue3 在性能、响应式系统、TS 支持、逻辑复用等方面较 Vue2 有显著提升，因此希望在不影响业务交付的前提下，将项目平滑迁移到 Vue3。

### 二、升级整体流程（渐进式迁移策略）

1. **依赖升级**

   - 升级 Vue2 → Vue3 (`vue@next`)
   - 升级 Vue Router（v3 → v4）、Vuex（或替换为 Pinia）

2. **构建工具改造**

   - Webpack → Vite
   - 替换 vue-loader、配置支持 `<script setup>`、TS 模块

3. **逐步重构组件**

   - 选取低风险模块做试点
   - 逐步将 Options API 重构为 Composition API

4. **重写 mixins / 插件**
   - 将 mixin 改写为 composable 函数
   - 用 props 和 emit 替代 this

---

### 三、常见问题与解决方案

| 问题类型            | 描述                                | 解决方案                                   |
| ------------------- | ----------------------------------- | ------------------------------------------ |
| 生命周期变化        | `beforeDestroy` → `onBeforeUnmount` | 使用组合式生命周期 API                     |
| `this` 失效         | setup() 中 `this` 为 undefined      | 用 `setup(props, { emit })` 替代访问方式   |
| 第三方库不兼容      | 如 ElementUI 不支持 Vue3            | 替换为 Element Plus / Naive UI             |
| `$listeners/$attrs` | 属性合并行为变化                    | 审查透传逻辑，适配 Vue3 的新继承机制       |
| 全局 API 变化       | Vue2 的 `Vue.use()` 等方法          | 替换为 `createApp().use()`                 |
| TS 类型变化         | 类型声明方式不同                    | 使用 `defineComponent` + `withDefaults` 等 |

### 四、优化方案

- 使用官方兼容包：[@vue/compat](https://github.com/vuejs/vue-compat)
- 编写单元测试确保迁移后功能一致
- 每次迁移拆解为小任务，利于回滚
- 重构逻辑同步更新团队协作方式与代码规范

### 五、答题话术

> “我参与了公司后台系统从 Vue2 到 Vue3 的升级，采用渐进式迁移策略。首先升级了核心依赖和构建工具，将 Webpack 替换为 Vite，并用 `defineComponent + setup` 改写核心模块逻辑。过程中遇到最大的问题是一些 mixin 无法直接替换为 hooks，我将其重构为 composable，并通过单元测试确保功能一致性。最终项目构建速度提升了 40%，逻辑更清晰，维护成本也降低了。”

#### 生命周期发生变化迁移优化策略

##### 一、生命周期对照表

| Vue2 生命周期 | Vue3 替代 API     | 执行阶段            |
| ------------- | ----------------- | ------------------- |
| beforeCreate  | —（合并进 setup） | 组件实例初始化前    |
| created       | —（合并进 setup） | 组件创建后          |
| beforeMount   | onBeforeMount     | DOM 挂载前          |
| mounted       | onMounted         | DOM 挂载后          |
| beforeUpdate  | onBeforeUpdate    | 更新前              |
| updated       | onUpdated         | 更新后              |
| beforeDestroy | onBeforeUnmount   | 卸载前              |
| destroyed     | onUnmounted       | 卸载后              |
| activated     | onActivated       | `<keep-alive>` 激活 |
| deactivated   | onDeactivated     | `<keep-alive>` 失活 |

##### 二、组合式 API 替代写法示例

###### ✅ Vue2 示例（Options API）

```js
export default {
  created() {
    this.init();
  },
  mounted() {
    this.fetchData();
  },
  beforeDestroy() {
    this.cleanUp();
  },
};
```

###### ✅ Vue3 示例（Composition API）

```ts
import { onMounted, onUnmounted } from "vue";

export default {
  setup(props, { emit }) {
    const fetchData = () => {
      /* 获取数据 */
    };
    const cleanUp = () => {
      /* 卸载清理 */
    };

    onMounted(() => {
      fetchData();
    });

    onUnmounted(() => {
      cleanUp();
    });

    return {
      /* 暴露组件内容 */
    };
  },
};
```

##### 三、具体迁移解决策略总结

- ✅ **created/beforeCreate → setup() 中初始化逻辑**
  - 这两个钩子合并到 setup() 中，初始化逻辑直接写在顶层。
- ✅ **beforeDestroy/destroyed → onBeforeUnmount/onUnmounted**
  - 可用于解绑事件、清理副作用等。
- ✅ **生命周期调用顺序不变**
  - Vue3 的生命周期钩子只是名称变化，时机本质和 Vue2 一致。
- ✅ **组合式函数中可封装生命周期逻辑**
  - 可以在 composable 中使用生命周期，增强复用性。

```ts
// useWebSocket.ts
export function useWebSocket() {
  onMounted(() => {
    connect();
  });
  onUnmounted(() => {
    disconnect();
  });
}
```

##### 四、答题话术

> “Vue3 生命周期用组合式 API 表达更清晰。原本写在 created 或 mounted 中的初始化逻辑现在直接写在 setup 顶层，卸载相关逻辑用 onUnmounted 替代 beforeDestroy。我在项目中会将常见逻辑封装进 composable，比如 usePolling 或 useWebSocket，使生命周期控制更集中、易复用。”

### 如何处理 Vue2 中的组件通信逻辑？

### Mixin 如何迁移为 Composition API？

#### 一、🌱 为什么要迁移 mixin？

Vue2 中的 mixin 虽然可以实现逻辑复用，但存在以下问题：

| 问题           | 描述                           |
| -------------- | ------------------------------ |
| 命名冲突风险   | 多个 mixin 的方法/变量容易重名 |
| 逻辑来源不清晰 | 方法来自哪里难以追溯           |
| 类型提示缺失   | 对 TypeScript 支持较差         |
| 可测试性弱     | 不易单元测试和复用             |

#### 二、🌟 Vue3 推荐使用 `composable` 替代 mixin

Composition API 提倡逻辑复用通过**函数抽离（composable）**实现。

> Composable 是一个普通的函数，内部使用 `ref`、`computed`、`watch`、生命周期钩子等组合式 API，将逻辑抽象封装。

#### 三、🚀 Mixin → Composable 的迁移步骤

1. **分析 mixin 的内容**

   - `data` → 转为 `ref` 或 `reactive`
   - `methods` → 普通函数
   - `computed` → `computed()`
   - `watch` → `watch()`
   - `生命周期钩子` → `onXXX()`

2. **创建 `useXXX()` 函数**

3. **在组件中使用**

#### 四、🧩 示例：从 mixin 到 composable

##### ✅ Vue2 中的 mixin：

```js
// loggerMixin.js
export default {
  data() {
    return { logCount: 0 };
  },
  methods: {
    log(msg) {
      this.logCount++;
      console.log(`[${this.logCount}] ${msg}`);
    },
  },
  mounted() {
    this.log("组件已挂载");
  },
};
```

##### ✅ Vue3 中的 composable：

```ts
// useLogger.ts
import { ref, onMounted } from "vue";

export function useLogger() {
  const logCount = ref(0);
  const log = (msg: string) => {
    logCount.value++;
    console.log(`[${logCount.value}] ${msg}`);
  };

  onMounted(() => {
    log("组件已挂载");
  });

  return { log, logCount };
}
```

##### ✅ 组件中使用：

```ts
import { useLogger } from "./useLogger";

export default {
  setup() {
    const { log } = useLogger();
    log("手动调用日志");

    return {};
  },
};
```

#### 五、🗣️ 面试话术模板（可背）

> “Vue3 中我会将 Vue2 的 mixin 逻辑迁移为 `composable` 函数，比如把日志记录逻辑抽象为 `useLogger`，用 `ref` 替代 data，函数内部使用生命周期钩子，比如 `onMounted`。这样做的好处是逻辑来源明确、命名冲突避免，并且可以独立测试和复用，在团队项目中效果非常好。”

### composable 和 mixin 的异同（Vue 面试常考）

#### 一、🌱 相同点

| 相同点             | 描述                                                   |
| ------------------ | ------------------------------------------------------ |
| 逻辑复用           | 都用于复用组件间的逻辑，比如轮询、事件监听、数据同步等 |
| 可在多个组件中使用 | 可跨组件共享功能                                       |
| 可以访问生命周期   | 都可以访问生命周期钩子控制逻辑时机                     |

---

#### 二、🚧 不同点对比

| 维度           | mixin（Vue2）                             | composable（Vue3）                           |
| -------------- | ----------------------------------------- | -------------------------------------------- |
| 本质           | 一个对象（包含 data/methods/computed 等） | 一个函数（返回响应式对象或函数）             |
| 使用方式       | 通过 `mixins: [xxMixin]` 注入             | 在 `setup()` 中直接调用：`useXxx()`          |
| 命名冲突       | 容易冲突（多个 mixin 合并到 this）        | 不会冲突（作用域封闭、变量自定义）           |
| 逻辑来源清晰度 | 差（方法来自哪个 mixin 不清楚）           | 清晰（从哪个 `useXXX()` 函数引入一目了然）   |
| 类型支持       | 差，TS 推导困难                           | 好，组合式 API 完全支持 TypeScript           |
| 调试能力       | 弱（this 上挂载很多不可见字段）           | 强（每个 composable 可独立调试、单元测试）   |
| 生命周期使用   | 写在组件中                                | 可在函数中使用生命周期钩子（如 `onMounted`） |
| 可测试性       | 差（全局混入不易单测）                    | 好（函数可单元测试、Mock、复用）             |

#### 三、🗣️ 面试话术模板

> “Mixin 是 Vue2 中常见的逻辑复用手段，但在实践中容易出现命名冲突、来源不明、类型难推导等问题。而 Vue3 的 composable 是基于 Composition API 的函数抽象方式，支持封装逻辑并返回响应式数据，不仅逻辑聚合清晰、变量作用域隔离，而且对 TypeScript 更友好，也方便测试和调试。在项目中我已经将常用 mixin 全部重构为 composable 函数，例如 usePolling、useLogger、useForm 等。”

### 如何保障升级过程中的线上稳定性？

#### 一、🧭 升级策略：渐进式迁移

- 拆分模块，优先升级非核心、非高流量页面
- 使用官方的兼容包 `@vue/compat` 实现 Vue2/3 混合运行
- 支持 Vue2 与 Vue3 并存（如 monorepo 或微前端架构）
- 分阶段替换组件与逻辑，逐步稳定替换关键路径

#### 二、🧪 自动化测试保障

| 类型     | 目标                                   |
| -------- | -------------------------------------- |
| 单元测试 | 保证核心逻辑函数和 composable 正确执行 |
| 组件测试 | 校验 props、事件、UI 行为是否一致      |
| E2E 测试 | 验证完整业务流程（如 登录 → 下单）     |

- 对升级模块补全测试覆盖率
- 升级前后运行测试集，确保功能无回归

#### 三、🔍 比对机制与双产线校验

- 新旧页面并存（如 /page-vue2 与 /page-vue3）
- 埋点监控或行为统计对比页面数据差异
- 可采用“影子发布”方式，业务无感知下测试 Vue3 页面表现

#### 四、📡 日志与监控体系

- 接入前端错误监控工具（如 Sentry）
- 接入性能埋点（如 FCP、LCP、JS 错误、白屏率等）
- Vue3 页面异常统一上报：白屏、网络异常、组件渲染失败等

#### 五、🧯 回滚策略与灰度发布

- 每次构建记录版本快照，支持快速版本回滚
- 灰度策略控制升级用户比例，逐步扩大范围
- 高优先级页面上线前先内测 / 小流量用户使用

#### 🎤 面试话术模板

> “在 Vue2 升级 Vue3 的过程中，我采用渐进式迁移方式，通过功能分包、双版本共存、可控灰度上线，保障升级风险。配合单元测试与 E2E 用例回归，确保功能一致性。我们还接入了 Sentry 做前端异常监控，并设置了版本快照回滚策略，一旦发现问题可在 5 分钟内切回旧版本，有效降低了升级风险。”

## Composition API 如何做逻辑复用和抽象？

### 一、核心思想：函数式组合（Function Composition）

> Composition API 通过将逻辑封装为 **可复用的函数（composable）**，实现更清晰、模块化的逻辑组织方式。

传统 Options API 会将一个功能分散在 `data`、`methods`、`computed` 中，难以维护。而 Composition API 可以将某一功能（如表单处理、弹窗控制、WebSocket 管理）**聚合在一个独立函数中**。

### 二、常见复用逻辑封装类型

| 类型         | 示例                            |
| ------------ | ------------------------------- |
| 状态逻辑     | `useToggle`、`useCounter`       |
| 网络请求     | `useFetch`、`useUserInfo`       |
| 表单处理     | `useForm`、`useFormRules`       |
| 生命周期控制 | `useScrollListener`、`useTimer` |
| 权限判断     | `usePermission`                 |
| 节流防抖     | `useDebounce`、`useThrottle`    |

### 三、封装步骤

1. **抽离逻辑为函数**：定义 `useXxx()` 函数
2. **使用组合式 API**：使用 `ref`、`reactive`、`computed`、`watch`、`onMounted` 等
3. **返回需要暴露的数据与方法**
4. **在组件 `setup()` 中调用复用逻辑**

### 四、示例：封装一个弹窗控制逻辑

```ts
// useModal.ts
import { ref } from "vue";

export function useModal() {
  const visible = ref(false);
  const open = () => (visible.value = true);
  const close = () => (visible.value = false);
  return { visible, open, close };
}
```

组件中使用：

```ts
import { useModal } from "./useModal";

export default {
  setup() {
    const { visible, open, close } = useModal();
    return { visible, open, close };
  },
};
```

### 五、优势总结

| 优势         | 描述                               |
| ------------ | ---------------------------------- |
| 聚合相关逻辑 | 类似“功能模块”而非“选项块”组织方式 |
| 可独立测试   | 函数式结构更适合写单元测试         |
| 无 this 依赖 | 更清晰、类型安全                   |
| 易于组合     | 可在一个组件中调用多个 composable  |
| 支持 TS 推导 | 类型系统完美兼容                   |

### 🎤 面试话术模板（推荐）

> “Composition API 让我可以将某个功能抽象为 composable 函数，比如弹窗、轮询、表单校验、权限控制等。每个 composable 都是功能独立、可复用、支持类型推导的函数，避免了 mixin 中的命名冲突与来源不清问题，让逻辑组织更加聚合、清晰，并可在多个组件中复用。”

### 你是否封装过复杂 composable？如何组织多个内部 composable？

#### 一、为什么迁移？

| 优势点     | 说明                               |
| ---------- | ---------------------------------- |
| 冷启动更快 | Vite 使用 ESBuild 预构建，秒级启动 |
| 构建更快   | 原生模块化，Rollup 高效打包        |
| 配置更简单 | 默认约定优于配置                   |
| 热更新快   | 模块级更新，无需整包替换           |

#### 二、核心配置迁移对照表

| 功能         | Webpack 配置                  | Vite 替代方式                        |
| ------------ | ----------------------------- | ------------------------------------ |
| 入口文件     | `entry: './src/main.js'`      | 默认使用 `index.html` 引入入口       |
| 别名 alias   | `resolve.alias`               | `resolve.alias`（相同）              |
| 环境变量     | `.env / process.env`          | `.env` + `import.meta.env`           |
| 静态资源     | `file-loader` / `url-loader`  | Vite 内置支持，无需额外 loader       |
| 热更新       | HMR 插件                      | Vite 默认支持                        |
| Babel 编译   | `babel-loader` + plugins      | Vite 使用 esbuild 替代（可选 Babel） |
| CSS 预处理器 | `sass-loader` / `less-loader` | Vite 自动识别对应依赖                |
| 插件系统     | Webpack plugins               | Vite plugins（基于 Rollup）          |
| 构建拆包     | `optimization.splitChunks`    | `rollupOptions.output.manualChunks`  |

#### 三、常见兼容性问题及解决方案

##### ✅ 1. CommonJS 模块不兼容（如 `require()`）

- **问题：** Vite 是原生 ESM 模块，不支持 CommonJS 动态导入
- **解决方案：**
  - 升级第三方包为 ESM 版本（或使用 vite-plugin-commonjs）
  - 使用 `import()` 替代 `require()`

##### ✅ 2. 全局变量问题（如 `process`, `__dirname`）

- **问题：** Vite 在浏览器环境中运行，无 Node 全局变量
- **解决方案：**
  - 配置 `define`:
    ```ts
    define: {
      'process.env': {}
    }
    ```
  - 或使用 polyfill 插件如 `vite-plugin-node-polyfills`

##### ✅ 3. HTML 模板不再用 HtmlWebpackPlugin

- Vite 直接使用 `index.html`，支持 EJS 模板语法
- 替代 `<%= BASE_URL %>` 等语法为 `import.meta.env.BASE_URL`

##### ✅ 4. 第三方 UI 库兼容性（如 ElementUI、iView）

- Vue2 项目需迁移到 Vue3（因为 Vite 默认支持 Vue3）
- Vue2 可使用 `vite-plugin-vue2` 支持旧项目（需额外配置）

#### 四、Vite 构建配置推荐（vite.config.ts）

```ts
import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      "@": "/src",
    },
  },
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ["vue", "vue-router"],
        },
      },
    },
  },
  define: {
    "process.env": {},
  },
});
```

#### 答题话术

> “在将 Webpack 项目迁移到 Vite 的过程中，我梳理了 alias、loader、plugin 等配置差异，并对静态资源、环境变量和构建优化做了适配。迁移中遇到最大的兼容问题是一些使用 CommonJS 的老库，我通过替换为 ESM 或配置插件解决。最终实现了启动速度提升 5 倍，构建时间缩短约 50%，热更新体验更流畅。”

## Composition API 相比 Options API 有哪些优势？

1. 逻辑聚合更清晰、更易于维护
   - 引入了`setup()`,可按功能组合代码(比如将表单逻辑集中在一个 `composable` 函数中)
   - 更适合大型项目的模块化
2. 响应式系统更灵活
   - `Composition API` 使用 `Vue3` 新的响应式系统（基于 `Proxy）`，,搭配 `ref` 和 `reactive` 能实现更精准的响应控制。
   - 可按需使用响应式变量，不再局限于 `data` 对象
   - 可以创建响应式函数和模块（如 `composable` `hooks`）
   - 支持逻辑抽离，不依赖 `this`
3. 生命周期更灵活,可重用性更强
   - `Vue3` 生命周期函数（如 `onMounted`, `onUnmounted`）可以在任何自定义函数中使用，支持复用逻辑中注册生命周期
4. 支持逻辑复用的函数式设计
   - `Composition API` 支持通过“composable”封装业务逻辑（如 useForm, useFetch），实现高度复用和测试友好
5. 更好的支持 TypeScript
   - `Composition API` 在类型推导、IDE 支持方面比 `Options API` 更友好

> **答题话术**
> “`Composition API` 更适合组织复杂组件逻辑，通过函数式组合实现代码聚合、逻辑复用，更利于维护和测试。同时搭配
> `Proxy` 响应系统与生命周期函数，可以让逻辑抽离到 composable 中，是真正面向模块化和大型应用的 API 设计。”

## Diff 算法

### 实现过程

> 通过对比前后两个虚拟 DOM 树,找出变化最小的集合,并以最优策略更新真实 DOM。

1. **同层比较**
   - Vue 默认只在同一层级进行节点对比，提升性能。
2. **核心对比策略**
   - 首尾双指针遍历(Head-to-Tail 比较)
   - 根据 key 快速定位变化位置
   - 移动/删除/新增节点操作精准控制
3. **patch 函数执行过程**
   - 判断节点类型是否相同->不同则替换
   - 判断 props 是否变化->做 attr 更新
   - 判断 children：
     - 文本 → 替换
     - 多子节点 → 调用 patchKeyedChildren 进行 Diff

### Vue3 Diff 算法 对比 Vue2 Diff 算法做了哪些优化

- Vue3 支持 Fragment、多根节点，因此 Diff 逻辑更灵活
- 当有 key 时，计算 最长递增子序列 以减少 DOM 移动次数（最少移动 = 保持顺序的最长子序列）
- Vue3 在模板编译阶段标记出哪些节点是静态的（patchFlag），运行时只更新动态部分
- 对静态 vnode 只创建一次，减少重复比较和创建过程

> 面试答题话术
> "Vue 的 Diff 算法是比较新旧 DOM,定位最小变化范围。`Vue2` 使用**双端对比方式**，性能还可以，但在长列表处理、节点移动上仍有优化空间。`Vue3` 引入了**最长递增子序列算法**，尽量减少 DOM 操作次数，同时利用模板编译时的静态提升（patchFlag + hoistStatic）标记静态内容，仅更新有变化的部分，极大提升了渲染性能。"

### Vue 和 React Diff 算法对比

#### 相同点

1. **使用虚拟 DOM:** 都通过构建 Virtual DOM 进行状态变化对比，提高性能和抽象能力
2. **基于同层比较:** 都默认不跨层级比较节点，以避免全量遍历
3. **依赖 key 提升属性:** 如果存在 key，会根据 key 快速定位节点变化
4. **目标是最小化 DOM 操作:** 尽可能少地执行增删改操作，提高渲染效率

#### 核心差异

| 维度 | Vue（特别是 Vue3） | React（特别是 Fiber 架构） |
| | -- | |
| **Diff 方式** | 基于传统递归 + 双端对比 + LIS 算法优化 | 基于 Fiber 架构，采用链表 + 分片时间切片遍历 |
| **性能优化点** | 模板静态提升（Hoist）+ patchFlag 动态标记 | 使用 reconciliation 协议做异步任务切分 |
| **长列表更新策略** | 使用 key + 最长递增子序列（LIS）优化节点移动 | 使用 key 匹配，新旧 key 不一致则直接替换 |
| **渲染模式** | 默认同步更新，可配合 Suspense 做异步 | 支持异步渲染（如 Concurrent Mode） |
| **核心目标** | 以最小 DOM 更新为目标 | 支持高并发、任务打断/恢复（即响应优先级） |
| **静态内容处理** | 编译期分析，标记哪些节点是静态内容 | 没有静态内容优化，所有 JSX 都视为 render 函数 |

> “Vue 和 React 都使用虚拟 DOM 和同层比较策略，但 React 在 Fiber 架构下更关注更新调度和异步优先级，适合高并发渲染场景，而 Vue3 侧重于模板编译优化和静态内容提升，配合最长递增子序列算法（LIS）来最小化 DOM 更新，渲染效率更高。两者的设计理念和实现路径略有不同，Vue 更注重运行效率，React 更注重更新流管理。”

## Vue 组件的通讯方式有哪些？

组件之间的通讯通常分为父子组件通讯和跨组件通讯。要注意，vue3 组件的通讯方式和 vue2 有一定的区别。

| 方式                          | 适用场景            | 实现方式                                                    | 性能考虑 |
| ----------------------------- | ------------------- | ----------------------------------------------------------- | -------- |
| props / emit                  | 父子组件通信        | 父组件传递数据，子组件监听事件                              | 简单     |
| ref                           | 跨组件访问 DOM 元素 | 在父组件中使用 `ref` 引用子组件实例                         | 简单     |
| provide / inject              | 跨组件共享数据      | 在父组件中使用 `provide` 提供数据，子组件使用 `inject` 注入 | 简单     |
| 自定义事件                    | 跨组件通信          | 自定义事件，通过 `$emit` 触发，`$on` 监听                   | 简单     |
| Vuex                          | 全局状态管理        | 集中管理应用状态                                            | 中等     |
| Pinia                         | 全局状态管理        | 集中管理应用状态                                            | 中等     |
| 第三方库（如 mitt、eventbus） | 全局事件总线        | 发布订阅模式，解耦组件通信                                  | 中等     |
| 自定义 Hook                   | 逻辑复用            | 封装可复用的逻辑，如 `useXxx`                               | 中等     |
| 上下文对象                    | 跨组件共享数据      | 使用 `provide` 和 `inject` 实现                             | 中等     |
| 全局对象                      | 全局共享数据        | 使用全局对象（如 `window`）                                 | 简单     |
| 自定义事件总线                | 全局事件总线        | 封装事件总线，解耦组件通信                                  | 中等     |

## 组件生命周期

Vue 组件的生命周期是指组件从创建到销毁的整个过程，包括组件的初始化、渲染、更新和销毁等阶段。在 Vue2 和 Vue3 中，组件的生命周期有一些区别。

### Vue2

- **创建阶段**

1️⃣ **beforeCreate**：组件实例刚被创建，数据观测和事件/监听器设置之前。此时无法访问 `data` 、 `computed` 和 `methods` 等。
2️⃣ **created**：组件实例已创建，数据观测、事件/监听器设置完成，此时可以访问 `data` 、 `computed` 和 `methods` 等，通常用于数据初始化。

- **挂载阶段**

3️⃣ **beforeMount**：在挂载开始之前，模板已编译， `el` 和 `template` 已经确定，但尚未渲染。
4️⃣ **mounted**：组件实例挂载到 DOM 上之后，此时可以访问和操作 DOM。

- **更新阶段**

5️⃣ **beforeUpdate**：数据发生变化，DOM 尚未更新。可以在这里做一些数据处理，避免不必要的渲染。
6️⃣ **updated**：数据变化，DOM 更新后调用。此时组件的 DOM 已经更新，可以访问和操作新的 DOM。

- **销毁阶段**

7️⃣ **beforeDestroy**：组件实例销毁之前。可以在此阶段进行清理工作，例如移除事件监听器、定时器等。
8️⃣ **destroyed**：组件实例销毁之后。此时，所有的事件监听器和子组件已被销毁。

### Vue3

- **创建阶段**

1️⃣ **onBeforeMount**：等效于 Vue 2 中的 `beforeMount` ，在组件挂载之前调用。
2️⃣ **onMounted**：等效于 Vue 2 中的 `mounted` ，在组件挂载之后调用。

- **更新阶段**

3️⃣ **onBeforeUpdate**：等效于 Vue 2 中的 `beforeUpdate` ，在数据更新之前调用。
4️⃣ **onUpdated**：等效于 Vue 2 中的 `updated` ，在数据更新并渲染之后调用。

- **销毁阶段**

5️⃣ **onBeforeUnmount**：等效于 Vue 2 中的 `beforeDestroy` ，在组件卸载前调用。
6️⃣ **onUnmounted**：等效于 Vue 2 中的 `destroyed` ，在组件卸载后调用。

tip setup 与生命周期

setup 作为 Vue3 的 Composition API 的一部分, 其内部函数的执行时机早于 Mounted 钩子。

```vue{7}
<script setup>
  import { ref, onMounted } from 'vue';
  console.log("setup");
  onMounted(() => {
  console.log('onMounted');
  });
  // 执行结果:setup onMounted
</script>

```

## Vue 组件在哪个生命周期发送 ajax 请求？

在 Vue 中，接口请求一般放在 `created` 或 `mounted` 生命周期钩子中。

**created 钩子**

- 优点：
  ✅ **更快获取数据**：能尽早获取服务端数据，减少页面加载时间。
  ✅ **SSR 支持**：支持服务器端渲染（SSR），在 SSR 环境中不会受到限制。

- 缺点
  ❌ UI 未渲染时发起请求：如果需要操作 DOM 或渲染数据，可能导致闪屏问题

**mounted 钩子**

- 优点：
  ✅ **DOM 可用**：适合需要操作 DOM 或渲染数据后再发起请求的情况，避免闪屏。

- 缺点
  ❌ **请求延迟**：数据请求会稍微延迟，增加页面加载时间。
  ❌ **SSR 不支持**：`mounted` 只在客户端执行，不适用于 SSR 环境。

## v-show 和 v-if 的区别

- **渲染方式：**
  💡v-if：条件为 true 时才会渲染元素，条件为 false 时销毁元素。
  💡v-show：始终渲染元素，只是通过 CSS 控制 `display 属性`来显示或隐藏。
- **适用场景：**
  💡v-if：适用于条件变化不频繁的场景。
  💡v-show：适用于条件变化频繁的场景。

## 为何 v-if 和 v-for 不能一起使用？

`v-if` 和 `v-for` 不能直接一起使用的原因，主要是因为它们在 **解析优先级** 和 **逻辑处理** 上存在冲突。

由于`v-for` 的解析优先级高于 `v-if`，同时使用 v-if 和 v-for，Vue 首先会循环创建所有 dom 元素，然后根据条件来判断是否渲染每个元素，这种方式可能导致 Vue 进行大量的 DOM 操作，性能较差。其次，`v-for` 会为每个循环项创建一个新的作用域，而 `v-if` 的条件如果依赖于这个作用域内的数据，可能导致判断逻辑异常。

为避免上述问题，vue 官方推荐我们将 `v-if` 放到 `v-for` 外层，或者将 `v-if` 放置到 `v-for` 内部的单个节点上。

```js
<div v-if="show">
  <div v-for="item in list" :key="item.id">{{ item.name }}</div>
</div>
```

## computed 和 watch 有什么区别

**computed**用于计算基于响应式数据的值，并缓存结果:

```vue
<template>
  <div>
    <p>原始值：{{ count }}</p>
    <p>计算后的数值：{{ doubledCount }}</p>
  </div>
</template>

<script setup>
import { ref, computed } from "vue";

const count = ref(2);

// 计算属性
const doubledCount = computed(() => count.value * 2);
</script>
```

**watch**用于监听数据变化并执行副作用操作

```vue
<template>
  <div>
    <p>原始数值：{{ count }}</p>
    <button @click="count++">增加数值</button>
  </div>
</template>

<script setup>
import { ref, watch } from "vue";

const count = ref(0);

// 监听器
watch(
  count,
  (newVal, oldVal) => {
    console.log(`数值从 ${oldVal} 变为 ${newVal}`);
  },
  // 立即生效immdiate
  //深度监听deep
);
</script>
```

| 特性 | `computed` | `watch` |
| | | -- |
| **用途** | 用于计算基于响应式数据的值，并缓存结果 | 用于监听数据变化并执行副作用操作 |
| **返回值** | 返回计算结果 | 不返回值，执行副作用 |
| **缓存机制** | 只有在访问时才会计算，会缓存计算结果，仅当依赖变化时重新计算 | 数据变化时立即执行回调，不缓存，每次数据变化都会触发回调 |
| **适用场景** | 计算派生数据，避免不必要的重复计算 | 执行异步操作、处理副作用操作，如 API 请求 |
| **性能** | 性能较好，避免重复计算 | 每次数据变化时都会执行回调函数 |

## watch 和 watchEffect 的区别

### 依赖追踪方式

`watch` ：需要**显式声明依赖，**监听指定的数据源\*\*；可以监听多个数据源或进行深度监听。

```js
import { watch, reactive } from "vue";
const state = reactive({
  count: 0,
});
watch(
  () => state.count, // 显式声明监听的依赖
  (newCount, oldCount) => {
    console.log(`新值 ${newCount} 老值 ${oldCount}`);
  },
);
```

`watchEffect` ：会自动追踪 **作用域内所有的响应式依赖**，不需要显式声明依赖。

```js
import { watchEffect, reactive } from "vue";
const state = reactive({
  count: 0,
});
watchEffect(() => {
  console.log(`Count 变化了: ${state.count}`); // 自动追踪 `state.count`
});
```

### 执行时机

`watch` ：在监听的响应式数据变化后立即执行。

`watchEffect` ：在 **组件挂载时** 执行一次副作用，并在 **依赖发生变化时** 再次执行。

### 适用场景

`watch` ：适用于 **监听特定数据** 变化并执行副作用的场景，如 API 请求、保存操作等。适合需要 **访问新值和旧值** 进行比较的场景。

`watchEffect` ：不需要访问旧值，适用于 **自动追踪多个响应式依赖** 的副作用，如渲染、自动保存等。

## 插槽(Slot)

slot 是 Vue 中的一种用于 组件内容分发 的机制。它允许父组件向子组件插入内容，从而使组件更加灵活和可复用。

在 Vue 中，插槽的使用方式可以分为四种：**默认插槽**、**具名插槽**、**条件插槽**和**作用域插槽**。

### 默认插槽

默认插槽是最简单的插槽形式，它允许我们将组件的内容传递到组件内部的一个占位符中。

子组件 `MyComponent.vue`

```vue
<template>
  <div>
    <p>我是子组件的标题</p>
    <slot></slot>
  </div>
</template>
```

父组件

```vue
<template>
  <MyComponent>
    <p>这是插槽内容，由父组件传入</p>
  </MyComponent>
</template>
```

输出结果：

```html
<div>
  <p>我是子组件的标题</p>
  <p>这是插槽内容，由父组件传入</p>
</div>
```

### 具名插槽

当子组件需要多个插槽时，可以为插槽命名，并由父组件指定内容放置到哪个插槽。

子组件 `MyComponent.vue`

```vue
<template>
  <slot name="header">默认标题</slot>
  <slot>默认内容</slot>
  <slot name="footer">默认页脚</slot>
</template>
```

父组件

```vue
<template>
  <MyComponent>
    <template v-slot:header>
      <h1>我来组成头部</h1>
    </template>
    <!-- 隐式的默认插槽 -->
    <p>我来组成身体</p>
    <template v-slot:footer>
      <p>我来组成尾部</p>
    </template>
  </MyComponent>
</template>
```

输出结果：

```html
<div>
  <h1>我来组成头部</h1>
  <p>我来组成身体</p>
  <p>我来组成尾部</p>
</div>
```

> `v-slot` 有对应的简写 `#` ，因此 `<template v-slot:header>` 可以简写为 `<template #header>` 。其意思就是“将这部分模板片段传入子组件的 header 插槽中”。

### 条件插槽

我们可以根据插槽是否存在来渲染某些内容:

子组件 `MyComponent.vue`

```vue
<template>
  <div class="card">
    <div v-if="$slots.header" class="card-header">
      <slot name="header" />
    </div>

    <div v-if="$slots.default" class="card-content">
      <slot />
    </div>

    <div v-if="$slots.footer" class="card-footer">
      <slot name="footer" />
    </div>
  </div>
</template>
```

### 作用域插槽

作用域插槽可以让子组件在渲染时将一部分数据提供给插槽，从而实现父组件的插槽访问到子组件的状态。

子组件 `MyComponent.vue`

```vue
<template>
  <ul>
    <!-- 定义作用域插槽，并将 items 数据传递给父组件 -->
    <slot :items="items"></slot>
  </ul>
</template>

<script setup>
import { ref } from "vue";

// 定义数据 items
const items = ref(["华为", "小米", "苹果"]);
</script>
```

```vue
<template>
  <MyComponent>
    <!-- 使用作用域插槽，接收子组件传递的 items 数据 -->
    <template #default="{ items }">
      <li v-for="(item, index) in items" :key="index">
        {{ item }}
      </li>
    </template>
  </MyComponent>
</template>

<script setup>
import MyComponent from "./MyComponent.vue";
</script>
```

输出结果：

```html
<ul>
  <li>华为</li>
  <li>小米</li>
  <li>苹果</li>
</ul>
```

> tip 应用场景
> 💡 灵活的组件内容插入：
> 插槽允许我我们将内容插入组件中，而无需修改子组件内部逻辑，极大提高了组件的灵活性。
> 💡 构建通用组件：
> 比如开发卡片、模态框、列表等组件，使用插槽可以轻松实现内容的自定义。模态框组件可通过插槽自定义标题、正文和按钮。
>
> 💡 减少重复代码：
> 通过插槽，将公共逻辑封装到子组件中，而在父组件中只需插入变化的内容。

## 为何 v-for 需要使用 key

在 Vue.js 中，使用 `v-for` 渲染列表时，添加 key 属性是一个重要的最佳实践。

- **提高性能**：当 Vue 更新视图时，它会根据 `key` 来识别哪些元素被修改、添加或移除。如果没有 `key`，Vue 会依赖其默认的算法（基于元素的位置）来比较元素，这样可能导致不必要的 DOM 操作。使用 `key` 后，Vue 能精确地找到每个项，从而减少不必要的 DOM 重排和重绘，提升性能。
- **保持组件状态**：如果渲染的是一个组件（而不是普通的 DOM 元素），使用 `key` 可以确保组件在渲染更新时保持正确的状态。例如，如果列表中有表单输入框，每个输入框都有自己的状态，使用 `key` 可以确保输入框状态不会因列表排序或元素移除而丢失。
- **避免渲染错误**：key 的存在可以帮助 Vue 确保在列表更新时，元素的顺序和内容保持稳定，避免出现不稳定的渲染或顺序错乱。

## 简述 Vue 组件异步更新的过程

Vue 组件的异步更新过程是其响应式系统的核心机制，主要通过 **批量更新** 和 **事件循环** 实现高效渲染，具体流程如下：

**一、触发阶段：依赖收集与变更通知**

1. **数据变更**
   当组件内响应式数据（如 `data` 、 `props` ）被修改时，触发 `setter` 通知依赖（Watcher）。

2. **Watcher 入队**
   所有关联的 Watcher 会被推入 **异步更新队列**（ `queueWatcher` ），Vue 通过 `id` 去重，确保每个 Watcher 仅入队一次，避免重复更新。

**二、调度阶段：异步队列处理** 3. **异步执行**
Vue 将队列刷新任务放入微任务队列（优先 `Promise.then` ，降级 `setImmediate` 或 `setTimeout` ），等待当前同步代码执行完毕后处理。

```javascript
// 伪代码：nextTick 实现
const timerFunc = () => {
  if (Promise) {
    Promise.resolve().then(flushQueue);
  } else if (MutationObserver) {
    /* 使用 MO */
  } else {
    setTimeout(flushQueue, 0);
  }
};
```

4. **合并更新**
   同一事件循环中的多次数据变更会被合并为一次组件更新（如循环中修改数据 100 次，仅触发 1 次渲染）。

**三、执行阶段：虚拟 DOM 与 DOM 更新** 5. **组件重新渲染**
执行队列中的 Watcher 更新函数，触发组件的 `render` 生成新虚拟 DOM（VNode）。

6. **Diff 与 Patch**
   通过 **Diff 算法** 对比新旧 VNode，计算出最小化 DOM 操作，批量更新真实 DOM。

**四、核心优势**

- **性能优化**：避免频繁 DOM 操作，减少重排/重绘。
- **数据一致性**：确保在同一事件循环中的所有数据变更后，视图一次性更新到最终状态。
- **开发者友好**：通过 `Vue.nextTick(callback)` 在 DOM 更新后执行逻辑。

```javascript
export default {
  data() {
    return {
      count: 0,
    };
  },
  methods: {
    handleClick() {
      this.count++; // Watcher 入队
      this.count++; // 去重，仍只一个 Watcher
      this.$nextTick(() => {
        console.log("DOM已更新:", this.$el.textContent);
      });
    },
  },
};
```

点击事件中两次修改 `count` ，但 DOM 仅更新一次， `nextTick` 回调能获取最新 DOM 状态。

**总结流程图**

```
数据变更 → Watcher 入队 → 微任务队列 → 批量执行 Watcher → 生成 VNode → Diff/Patch → DOM 更新
```

通过异步更新机制，Vue 在保证性能的同时，实现了数据驱动视图的高效响应。

## Vue 组件是如何渲染和更新的

Vue 组件的渲染和更新过程涉及从 `模板编译` 到 `虚拟 DOM` 的**构建**、**更新**和最终的实际 DOM 更新。下面是 Vue 组件渲染和更新的主要步骤：

1️⃣ 组件渲染过程
Vue 的组件的渲染过程核心是其[模板编译](./vue-inner/#vue-模板编译的过程)过程，大致流程如下：
首先，Vue 会通过其响应式系统完成组件的 `data、computed 和 props` 等数据和模板的绑定，这个过程 Vue 会利用 `Object.defineProperty（Vue2）` 或 `Proxy（Vue3）` 来追踪数据的依赖，保证数据变化时，视图能够重新渲染。随后，Vue 会将模板编译成渲染函数，这个渲染函数会在每次更新时被调用，从而生成虚拟 DOM。
最终，虚拟 DOM 被渲染成真实的 DOM 并插入到页面中，组件渲染完成，组件渲染的过程中，Vue 会依次触发相关的生命周期钩子。

2️⃣ 组件更新过程
当组件的状态（如 data、props、computed）发生变化时，响应式数据的 `setter` 方法会让调用 Dep.notify 通知所有 `订阅者Watcher` ，重新执行渲染函数触发更新。

![](../imgs/vue/模板编译.png)

渲染函数在执行时，会使用 diff 算法（例如：双端对比、静态标记优化等）生成新的虚拟 DOM。计算出需要更新的部分后（插入、删除或更新 DOM），然后对实际 DOM 进行最小化的更新。在组件更新的过程中，Vue 会依次触发 beforeUpdate、updated 等相关的生命周期钩子。

## 如何实现 keep-alive 缓存机制

`keep-alive` 是 Vue 提供的一个内置组件，用来缓存组件的状态，避免在切换组件时重新渲染和销毁，从而提高性能。

```vue
<template>
  <keep-alive>
    <component :is="currentComponent" />
  </keep-alive>
</template>
```

Vue 3 的 keep-alive 的缓存机制原理如下：

- 缓存池：keep-alive 内部使用一个 Map 存储已渲染的组件实例，键通常是组件的 key（或 name）。
- 激活与挂起：如果组件切换时已经缓存，直接复用缓存的组件实例；如果组件未缓存，则渲染并缓存新的组件实例。
  此外，keep-alive 还会激活特殊的钩子函数：
- 当组件被缓存时，会触发 deactivated 钩子。
- 当组件从缓存中恢复时，会触发 activated 钩子。

一个简单的实现如下：

```javascript
const KeepAliveImpl = {
  name: "KeepAlive",
  // 已缓存的组件实例。
  _cache: new Map(),
  _activeCache: new Map(),

  render() {
    const vnode = this.$slots.default()[0]; // 获取动态组件的 vnode
    const key = vnode.key || vnode.type.name;

    if (this._cache.has(key)) {
      const cachedVnode = this._cache.get(key);
      this._activeCache.set(key, cachedVnode);
      return cachedVnode;
    } else {
      return vnode; // 未缓存，直接渲染
    }
  },

  mounted() {
    const key = this.$vnode.key;
    if (!this._cache.has(key)) {
      this._cache.set(key, this.$vnode);
    }
  },

  beforeDestroy() {
    const key = this.$vnode.key;
    this._cache.delete(key);
  },
};
```

## 为何 ref 需要 value 属性

Vue 3 中， `ref` 之所以需要 `.value` 属性，主要是因为 Vue 3 使用 `Proxy` 实现响应式。 `Proxy` 对对象或数组的每个属性进行深度代理，因此可以追踪嵌套属性的变化。而 `Proxy` 无法直接处理基本数据类型（如 `number` 、 `string` 、 `boolean` ），这使得 `reactive` 无法用于基本数据类型。为了实现基本数据类型的响应式，Vue 设计了 `ref` ，它将基本数据类型封装为一个包含 `value` 属性的对象，并通过 `getter` 和 `setter` 进行依赖追踪和更新。当访问或修改 `ref.value` 时，Vue 会触发依赖更新。

## Vue 父子组件生命周期调用顺序

1️⃣ 创建阶段

- 父组件：`beforeCreate` ➡️ `created`

- 子组件：`beforeCreate` ➡️ `created`

- 顺序：
  父组件的 `beforeCreate` 和 `created` 先执行 ，子组件的 `beforeCreate` 和 `created` 后执行。

  > 原因：父组件需要先完成自身的初始化（如 data、computed 等），才能解析模板中的子组件并触发子组件的初始化。

2️⃣ 挂载阶段

- 父组件：`beforeMount`

- 子组件：`beforeMount` ➡️ `mounted`

- 父组件：`mounted`

- 顺序：
  父 `beforeMount` → 子 `beforeCreate`→ 子 `created`→ 子 `beforeMount`→ 子 `mounted` → 父 `mounted`

  > 原因：父组件在挂载前（beforeMount）需要先完成子组件的渲染和挂载，因为子组件是父组件模板的一部分。只有当所有子组件挂载完成后，父组件才会触发自身的 mounted。

3️⃣ 更新阶段

- 父组件：`beforeUpdate`

- 子组件：`beforeUpdate` ➡️ `updated`

- 父组件：`updated`

- 顺序：
  父 `beforeUpdate` → 子 `beforeUpdate` → 子 `updated` → 父 `updated`

  > 原因：父组件的数据变化会触发自身更新流程，但子组件的更新必须在父组件更新前完成（因为子组件可能依赖父组件的数据），最终父组件的视图更新完成。

4️⃣ 销毁阶段

- 父组件：`beforeDestroy`

- 子组件：`beforeDestroy` ➡️ `destroyed`

- 父组件：`destroyed`

- 顺序：
  父 `beforeDestroy` → 子 `beforeDestroy` → 子 `destroyed` → 父 `destroyed`

  > 原因：父组件销毁前需要先销毁所有子组件，确保子组件的资源释放和事件解绑，避免内存泄漏。

tip
注：vue3 中，`setup()` 替代了 `beforeCreate` 和 `created`，但父子组件的生命周期顺序不变。

## Vue3 ref 和 reactive 如何选择？

`ref` 和 `reactive` 都是 Vue 3 中用来创建响应式数据的 API，他们的区别及使用场景如下。

- **reactive 的实现：**
  `reactive` 通过 `Proxy` 对对象或数组的每个属性进行深度代理，实现响应式。这种设计使得 `reactive` 能自动追踪所有嵌套属性的变化，但由于 `Proxy` 无法直接处理基本数据类型（如 `number` 、 `string` 、 `boolean` ），因此， `reactive` 不适用于基本数据类型。

- **ref 的实现：**
  为了实现基本数据类型的响应式，Vue 设计了 `ref` 。 `ref` 会将基本数据类型封装为一个包含 `value` 属性的对象，通过 `getter` 和 `setter` 实现响应式依赖追踪和更新。当访问或修改 `ref.value` 时，Vue 内部会触发依赖更新。此外，对于复杂数据类型（如对象或数组）， `ref` 的内部实现会直接调用 `reactive` ，将复杂数据类型变为响应式。

tip 如何选择

**Vue 官方建议**使用 `ref()` 作为声明响应式状态的主要，因为 `reactive` 存在以下局限性：

💡 有限的值类型：它只能用于对象类型 (对象、数组和如 Map、Set 这样的集合类型)。它不能持有如 string、number 或 boolean 这样的原始类型。
💡 不能替换整个对象：由于 Vue 的响应式跟踪是通过属性访问实现的，因此我们必须始终保持对响应式对象的相同引用。这意味着我们不能轻易地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失：

```js
let state = reactive({
  count: 0,
});

// 上面的 ({ count: 0 }) 引用将不再被追踪
// (响应性连接已丢失！)
state = reactive({
  count: 1,
});
```

💡 对解构操作不友好：当我们将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，我们将丢失响应性连接

```js
const state = reactive({
  count: 0,
});
// 当解构时，count 已经与 state.count 断开连接
let { count } = state;
// 不会影响原始的 state
count++;

// 该函数接收到的是一个普通的数字
// 并且无法追踪 state.count 的变化
// 我们必须传入整个对象以保持响应性
callSomeFunction(state.count);
```

## 什么是动态组件？如何使用它？

动态组件是 Vue 提供的一种机制，允许我们根据条件动态切换渲染的组件，而不需要手动修改模板。
在 Vue 中，我们可以通过 ` <component>` 标签的 `:is` 属性指定需要渲染的组件：

```vue
<template>
  <div>
    <!-- 动态渲染组件 -->
    <component :is="currentComponent"></component>

    <!-- 控制组件切换 -->
    <button @click="currentComponent = 'ComponentA'">显示组件A</button>
    <button @click="currentComponent = 'ComponentB'">显示组件B</button>
  </div>
</template>

<script setup>
import { ref } from "vue";
import ComponentA from "./ComponentA.vue";
import ComponentB from "./ComponentB.vue";

// 当前显示的组件
const currentComponent = ref("ComponentA");
</script>
```

`<component>` 标签的 `:is` 属性值可以是：

- 被注册的组件名
- 导入的组件对象
- 一般的 HTML 元素

当使用 `<component :is="...">` 来在多个组件间作切换时，被切换掉的组件会被卸载。如果需要保留动态组件状态，使用 `<KeepAlive>` 组件即可。

## Vue 项目可做哪些性能优化？

🔍 在 Vue 项目中，我们可以利用 Vue 特有的功能和机制实现性能优化。

### 模板和指令优化

- 合理的使用 `v-if` 和 `v-show` 指令，避免不必要的渲染。
- 使用 `v-for` 时，尽量提供唯一的 `key` ，避免重复渲染。
- 使用 `v-once` 指令，只渲染一次，避免不必要的计算。
- 使用 `v-memo` 指令，对使用`v-for`生成的列表进行渲染优化。`(vue3.2新增)`

### 组件优化

- 合理使用 `keep-alive` 组件，缓存组件实例，避免重复渲染。
- 使用异步组件加载，减少首屏加载时间。

```js
const AsyncComponent = defineAsyncComponent(() => import("./MyComponent.vue"));
```

- 配合 Vue Router 使用路由懒加载，实现路由页面按需加载。
- 合理划分组件，提升复用性和渲染性能。

### 响应式优化

- 使用 `Object.freeze` 冻结对象，避免不必要的响应式。

- 使用 stop 停止 不必要的 watchEffect 副作用执行，以减少性能消耗。

- watch 的优化

  💡 避免滥用深度监听，降低性能开销。

  💡 对于频繁触发的响应式数据变化，可以通过防抖和节流优化监听逻辑。

```js
import { debounce } from "lodash";

watch(
  () => searchQuery,
  debounce((newQuery) => {
    fetchSearchResults(newQuery);
  }, 300),
);
```

💡 可以通过返回函数只监听具体的依赖，减少不必要的触发。

```js
watch([() => user.name, () => user.age], ([newName, newAge]) => {
  //...
});
```

💡 当监听器在某些条件下不再需要时，可以通过返回的 stop 方法手动停止监听，以节省资源

```js
const stop = watch(
  () => data.value,
  (newValue) => {
    if (newValue === "done") {
      stop(); // 停止监听
    }
  },
);
```

💡 当多个监听器的回调逻辑类似时，可以合并监听

```js
watch([() => user.name, () => user.age], ([newName, newAge]) => {
  //...
});
```

## 什么是 nextTick 如何应用它

在 Vue.js 中， `nextTick` 是一个核心工具方法，用于处理 DOM 更新时机问题。它的核心作用是：**在下次 DOM 更新循环结束后执行回调，确保我们能操作到最新的 DOM 状态。**
它的使用场景如下：

- 数据变化后操作 DOM

```vue
<script setup>
async function increment() {
  count.value++;
  // DOM 还未更新
  console.log(document.getElementById("counter").textContent); // 0
  await nextTick();
  // DOM 此时已经更新
  console.log(document.getElementById("counter").textContent); // 1
}
</script>

<template>
  <button id="counter" @click="increment">{{ count }}</button>
</template>
```

- 在生命周期钩子中操作 DOM

```vue
<script setup>
import { ref, onMounted, nextTick } from "vue";
// 创建 DOM 引用
const element = ref(null);

onMounted(() => {
  // 直接访问可能未渲染完成
  console.log(element.value.offsetHeight); // 0 或未定义
  // 使用 nextTick 确保 DOM 已渲染
  nextTick(() => {
    console.log(element.value.offsetHeight); // 实际高度
  });
});
</script>
```

注意，在 vue2 中和 vue3 的选项式 API 中，我们使用 this.$nextTick(callback)的方式调用。

```js
this.$nextTick(() => {
  console.log(this.$refs.text.innerText); // "更新后的文本"
});
```

## 使用 Vue3 Composable 组合式函数，实现 useCount

tip

在 Vue 应用的概念中，“**组合式函数**”(Composables) 是一个利用 Vue 的组合式 API 来封装和复用有状态逻辑的函数。它和自定义 `React hooks` 非常相似。

使用组合式函数实现如下需求：useCount 是一个计数逻辑管理的组合式函数，它返回一个 `count` 变量和增加、减少、重置 count 的方法。

```vue
<script setup>
import { ref } from "vue";

// 实现 useCount 组合式函数
function useCount() {
  const count = ref(0);
  const increment = () => {
    count.value++;
  };
  const decrement = () => {
    count.value--;
  };
  const reset = () => {
    count.value = 0;
  };
  return {
    count,
    increment,
    decrement,
    reset,
  };
}

// 使用 useCount 组合式函数
const { count, increment, decrement, reset } = useCount();
</script>

<template>
  <div>
    <h2>计数器: {{ count }}</h2>
    <button @click="increment">增加</button>
    <button @click="decrement">减少</button>
    <button @click="reset">重置</button>
  </div>
</template>
```

## 使用 Vue3 Composable 组合式函数，实现 useRequest

```js
const { loading, data, error } = useRequest(url); // 可只考虑 get 请求
```

```ts
import { ref, computed } from 'vue';
import axios from 'axios';

// 实现 useRequest 组合式函数
function useRequest(url) {
  const loading = ref(false); // 请求状态
  const data = ref(null); // 响应数据
  const error = ref(null); // 错误信息

  const fetchData = async () => {
    loading.value = true;
    error.value = null;
    try {
      const response = await axios.get(url); /
      data.value = response.data;
    } catch (err) {
      error.value = err.message || '请求失败'; /
    } finally {
      loading.value = false;
    }
  };

  // 自动触发请求
  fetchData();

  return {
    loading,
    data,
    error,
  };
}

export default useRequest;
```

使用

```vue
<script setup>
import useRequest from "./useRequest";
const url = "https://www.mianshipai.com/";
const { loading, data, error } = useRequest(url);
</script>
<template>
  <div>
    <h2>请求数据</h2>
    <div v-if="loading">加载中...</div>
    <div v-else-if="error">{{ error }}</div>
    <div v-else>
      <p>{{ data }}</p>
    </div>
  </div>
</template>
```

## 自定义组件如何实现 v-model

`v-model` 可以在组件上使用以实现双向绑定。

details vue2
在 vue2 中，自定义组件使用 `v-model` ，需要在组件内部定义 `value` prop，然后通过 `this.$emit('input', newValue)` 触发更新即可。

```vue
<!-- CustomInput.vue -->
<template>
  <input :value="value" @input="$emit('input', $event.target.value)" />
</template>

<script>
export default {
  props: ["value"],
};
</script>
```

使用方式：

```vue
<CustomInput v-model="searchText" />
```

details vue3
与 vue2 类似，vue3 自定义组件使用 `v-model` ，需要在组件内部定义 `modelValue` prop，然后通过 `emit('update:modelValue', newValue)` 触发更新

```vue
<!-- CustomInput.vue -->
<template>
  <input
    :value="modelValue"
    @input="$emit('update:modelValue', $event.target.value)"
  />
</template>

<script setup>
defineProps(["modelValue"]);
defineEmits(["update:modelValue"]);
</script>
```

使用方式：

```vue
<CustomInput v-model="searchText" />
```

**👉 注意，从 Vue 3.4 开始，官方推荐的实现方式是使用 defineModel() 宏：**

```vue
<!-- Child.vue -->
<script setup>
const model = defineModel();

function update() {
  model.value++;
}
</script>

<template>
  <div>父组件的 v-model 值为: {{ model }}</div>
  <button @click="update">Increment</button>
</template>
```

父组件使用 v-model 绑定一个值：

```vue
<!-- Parent.vue -->
<Child v-model="countModel" />
```

`defineModel` 是一个便利宏，其返回的值是一个 `ref` 。它可以像其他 `ref` 一样被访问以及修改，不过它能起到在父组件和当前变量之间的双向绑定的作用：

- 它的 `.value` 和父组件的 `v-model` 的值同步；
- 当它被子组件变更了，会触发父组件绑定的值一起更新。
  根据 `defineModel` 的特性，我们可以用 `v-model` 把这个 `ref` 绑定到一个原生 `input` 元素上：

```vue
<script setup>
const model = defineModel();
</script>

<template>
  <input v-model="model" />
</template>
```

> 此外，v-model 可以接受自定义参数、添加修饰符，组件也可以绑定多个 v-model ，具体用法请参考
> 官网文档：[组件 v-model](https://cn.vuejs.org/guide/components/v-model)

## 如何统一监听 Vue 组件报错

在 Vue 3 中，可以通过 全局错误处理器 `（errorHandler）` 和 生命周期钩子（例如 `onErrorCaptured` ）来统一监听和处理组件中的错误。

- **通过全局错误处理器 `app.config.errorHandler`**

```TypeScript
import { createApp } from 'vue';
const app = createApp(App);
// 设置全局错误处理器
app.config.errorHandler = (err, instance, info) => {
  console.error('捕获到组件错误: ', err);
  console.log('发生错误的组件实例: ', instance);
  console.log('错误信息: ', info);
};

app.mount('#app');
```

- **局部错误捕获（onErrorCaptured）**

`onErrorCaptured` 钩子可以捕获后代组件传递过程中的错误信息

```vue
<script setup>
import { onErrorCaptured } from "vue";

onErrorCaptured((err, instance, info) => {
  console.error("局部捕获到错误: ", err);
  console.log("错误来源组件: ", instance);
  console.log("错误信息: ", info);

  // 这个钩子可以通过返回 false 来阻止错误继续向上传递。
  return false; // 如果需要让错误冒泡到全局，省略或返回 true
});
</script>

<template>
  <div>
    <h2>局部错误捕获示例</h2>
    <ErrorProneComponent />
  </div>
</template>
```

> Vue 官方 API： [onErrorCaptured](https://cn.vuejs.org/api/composition-api-lifecycle.html#onerrorcaptured)、[errorHandler](https://cn.vuejs.org/api/application.html#app-config-errorhandler)

## Vuex 中 mutation 和 action 有什么区别？

在 Vuex 中， `mutation` 和 `action` 是用于管理状态的两种核心概念。

`mutation` 可以直接修改 `store` 中的 **state**值，它只支持同步操作。 `Action` 不能直接修改 **state**，而是通过调用 `mutation` 来间接修改，它用于处理异步操作。

```js
const store = createStore({
  state: {
    count: 0, // 定义状态
  },
  mutations: {
    // Mutation 示例（同步）
    increment(state, payload) {
      state.count += payload;
    },
  },
});

// 组件中调用
this.$store.commit("increment", 5);
```

```js
const store = createStore({
  state: {
    count: 0, // 定义状态
  },
  mutations: {
    // Mutation：同步修改状态
    increment(state, payload) {
      state.count += payload;
    },
  },
  actions: {
    // Action：异步操作，延迟1秒后调用 mutation
    asyncIncrement({ commit }, payload) {
      setTimeout(() => {
        commit("increment", payload); // 提交 mutation 修改状态
      }, 1000);
    },
  },
});

// 组件中调用
this.$store.dispatch("asyncIncrement", 5);
```

**总结：**

| 特性 | Mutation | Action |
| | | - |
| 是否同步 | ✅ 同步 | ⏳ 异步（也可以处理同步） |
| 是否直接修改 state | ✅ 直接修改 | ❌ 通过调用 mutation 修改 |
| 调用方式 | `commit('mutationName')` | `dispatch('actionName')` |
| 适用场景 | 简单的状态修改 | 异步操作（如 API 调用） |
| 调试支持 | 完全支持，易于追踪 | 依赖于 mutation 的日志 |

tip ⚠️ 为什么要有这样的区分？

- 数据可预测性：通过强制 `Mutation` 同步修改 **State**，使得状态变更可追踪
- 调试友好性：DevTools 可以准确捕捉每次状态快照
- 代码组织：将同步逻辑与异步逻辑分离，提高代码可维护性

参考文章：[VueX 用法快速回顾](https://juejin.cn/post/7249033891809329212)

## Vuex 和 Pinia 有什么区别？

`Pinia` 和 `Vuex` 都是 Vue 的专属状态管理库，允许用户跨组件或页面共享状态。

- **区别**

| 特性 | **Vuex** | **Pinia** |
| - | | -- |
| **版本支持** | Vue 2 和 Vue 3 | 仅支持 Vue 3（基于 `Composition API` ） |
| **API 风格** | 基于传统的对象式 API | 基于 Composition API，类似于 `setup` <br/> 语法 |
| **模块管理** | 支持模块化（modules），但语法较复杂 | 模块化简单，**每个 store 就是一个独立模块** |
| **TypeScript 支持** | `TypeScript` 支持不完善，需手动定义类型 | 开箱即用的 `TypeScript` 支持，类型推导更强大 |
| **性能** | 更适合大型项目，但冗余代码较多 | 更加轻量，性能更好，支持按需加载 |
| **状态持久化** | 需要额外插件 | 插件系统更加灵活，支持状态持久化插件 |

- **代码对比**

📝 **vuex**

```javascript
// store.js
import { createStore } from "vuex";

const store = createStore({
  state: {
    count: 0,
  },
  mutations: {
    increment(state) {
      state.count++;
    },
  },
  actions: {
    asyncIncrement({ commit }) {
      setTimeout(() => {
        commit("increment");
      }, 1000);
    },
  },
  getters: {
    doubleCount: (state) => state.count * 2,
  },
});

export default store;
```

vue 组件中使用

```vue
<script>
export default {
  // 计算属性
  computed: {
    count() {
      return this.$store.state.count;
    },
    doubleCount() {
      return this.$store.getters.doubleCount;
    },
  },
  methods: {
    // 同步增加
    increment() {
      this.$store.commit("increment");
    },
    // 异步增加
    asyncIncrement() {
      this.$store.dispatch("asyncIncrement");
    },
  },
};
</script>
```

📝**Pinia**

```typescript
// store.js
import { defineStore } from "pinia";

export const useCounterStore = defineStore("counter", {
  state: () => ({
    count: 0,
  }),
  actions: {
    increment() {
      this.count++;
    },
    async asyncIncrement() {
      setTimeout(() => {
        this.increment();
      }, 1000);
    },
  },
  getters: {
    doubleCount: (state) => state.count * 2,
  },
});
```

组件中使用：

```vue
<script setup>
import { useCounterStore } from "./store";
const counter = useCounterStore();
</script>

<template>
  <h1>Count的计算值 {{ counter.count }}</h1>
  <h2>Double的计算值 {{ counter.doubleCount }}</h2>
  <button @click="counter.increment">同步增加</button>
  <button @click="counter.asyncIncrement">异步增加</button>
</template>
```

- **如何选择？**

对于 vue3 项目，官方推荐使用 pinia。因为它**更轻量、TypeScript 支持更好、模块化更简单且拥有更强的 DevTools 支持**。

## Vue-router 导航守卫能用来做什么？

`vue Router` 的**导航守卫**用于在路由跳转过程中对导航行为进行**拦截**和**控制**。这些守卫在路由进入、离开或更新时执行，可以用于多种场景，确保应用的导航逻辑符合预期。以下是常见的用途：

- 认证和授权

用于检查用户的登录状态或权限，防止未授权用户访问受限页面。

```javascript
router.beforeEach((to, from, next) => {
  const isAuthenticated = !!localStorage.getItem("token");
  if (to.meta.requiresAuth && !isAuthenticated) {
    next("/login"); // 未登录，跳转到登录页
  } else {
    next(); // 已登录，正常导航
  }
});
```

- 数据预加载

在进入路由前预加载必要的数据，确保页面渲染时数据已准备好。

```javascript
router.beforeEach(async (to, from, next) => {
  if (to.name === "userInfo") {
    await store.dispatch("fetchUserData"); // 预加载用户数据
  }
  next();
});
```

- 动态修改页面标题

根据路由信息动态更改浏览器标签页的标题，提升用户体验。

```javascript
router.afterEach((to) => {
  document.title = to.meta.title || "自定义标题";
});
```

- 动画和加载效果

在路由切换时展示加载动画或过渡效果，提升用户体验。

```javascript
router.beforeEach((to, from, next) => {
  store.commit("setLoading", true); // 开始加载动画
  next();
});

router.afterEach(() => {
  store.commit("setLoading", false); // 结束加载动画
});
```

- 日志记录和分析

在路由切换时记录用户行为，用于分析或调试。

```javascript
router.afterEach((to, from) => {
  console.log(`用户从 ${from.fullPath} 跳转到 ${to.fullPath}`);
});
```

- 防止访问不存在的页面

通过守卫检查路由是否存在，避免导航到无效页面。

```javascript
router.beforeEach((to, from, next) => {
  const routeExists = router
    .getRoutes()
    .some((route) => route.name === to.name);
  if (!routeExists) {
    next("/404"); // 跳转到 404 页面
  } else {
    next();
  }
});
```

## 你在项目中如何封装 Composition API？

答：

- 将重复逻辑封装成组合函数，如 `usePagination`、`useFetchData`；
- 组合函数返回响应式数据和方法，支持解耦复用；
- 支持生命周期钩子调用、异步处理、默认值设置等；
- 与组件 `setup()` 保持纯净逻辑，提升代码可读性与可维护性。

## ref 和 reactive 有什么区别？解构 reactive 会失效吗？

答：

- `ref` 适用于基本类型（如数字、布尔、字符串），`reactive` 更适用于对象和数组；
- 解构 `ref` 时需 `.value` 访问，解构 `reactive` 会失去响应式；
- 需要用 `toRefs()` 将 reactive 转成可响应解构值。

## 如何理解 watch 和 watchEffect 的区别？

答：

- `watch` 更适合明确指定数据的变化处理；
- `watchEffect` 会自动收集依赖，首次立即执行；
- `watchEffect` 更适合副作用追踪，`watch` 适合明确字段控制变化逻辑；
- `watch` 可选配置如 `deep`、`immediate` 提高控制能力。

## 如何在 Vue 中实现组件的按需加载？

答：

- 使用 Vue 的异步组件（`defineAsyncComponent`）或 `Suspense` 组件；
- 路由懒加载：`const Home = () => import('./Home.vue')`；
- 动态导入：`import('./Component.vue')`；

## 你在 Vue 3 项目中如何做请求封装的？

答：
• 使用 Axios 封装请求实例，加入请求/响应拦截器；
• 自动携带 token，失败统一提示；
• 区分 RESTful 错误码，例如处理 401 自动跳转登录；
• 把常用方法封装为统一接口文件 api/user.ts。

## Vue 3 中如何实现权限控制？

答：
• 登录成功后获取用户权限（后端返回角色/菜单/按钮）；
• 前端通过 meta.permission 配合路由守卫控制访问权限；
• 菜单渲染/按钮控制通过指令或 v-if 权限码判断；
• 对于没有权限的路由跳转 403 页面。

## 如何设计一个高复用的 Vue3 表单组件？

答：
• 表单项配置通过 schema 形式传入；
• 使用 v-model + defineExpose 暴露方法（如校验、重置）；
• 支持插槽自定义表单项；
• 动态绑定 rules，支持异步校验与联动规则变更。

## 逻辑复用（useXxx 组合函数）

### 答题话术：

> Vue3 Composition API 提供了组合函数能力，我通过封装如 `useTable`、`useForm`、`usePagination` 等，实现逻辑复用、数据抽离、提升组件可维护性。

### 实战举例：

#### usePagination.ts

```ts
import { ref } from "vue";

export function usePagination(defaultPageSize = 10) {
  const current = ref(1);
  const pageSize = ref(defaultPageSize);
  const total = ref(0);

  const reset = () => {
    current.value = 1;
    total.value = 0;
  };

  return {
    current,
    pageSize,
    total,
    reset,
  };
}
```

#### 使用示例：

```ts
const { current, pageSize, total, reset } = usePagination();
```

## ref vs reactive 的区别与使用场景

| 特性 | `ref` | `reactive` |
| | | |
| 用于 | 基础类型或单值引用 | 对象、数组、嵌套结构 |
| 响应式 | `.value` 访问 | 自动代理 |
| 解构时 | 会失去响应式 | 解构仍保持响应式（配合 `toRefs`） |

### 面试答题模板：

> `ref` 适用于基础类型响应式，`reactive` 更适合对象类型；
> 在解构 `reactive` 对象时需结合 `toRefs`，否则会失去响应式。

## watch/watchEffect 实战场景

### 使用场景：

- 表单字段联动
- 路由变化监听
- 节流 + 请求
- 自动计算依赖变化执行逻辑

### 示例：监听搜索关键词节流请求

```ts
const keyword = ref("");
watch(keyword, debounceFetch, { immediate: true });

function debounceFetch(val: string) {
  clearTimeout(timeout.value);
  timeout.value = setTimeout(() => {
    fetchData(val);
  }, 300);
}
```

## 使用 `provide` / `inject` 跨组件通信

> 适用于非父子关系通信、深层组件共享状态。

### 使用案例：

```ts
// 父组件 setup 中
provide("theme", ref("dark"));

// 子组件 setup 中
const theme = inject("theme");
```

## 组合函数 + 生命周期

> 组合函数中可直接使用生命周期钩子（如 `onMounted`, `onUnmounted`）

```ts
export function useWindowSize() {
  const width = ref(window.innerWidth);
  const height = ref(window.innerHeight);

  const update = () => {
    width.value = window.innerWidth;
    height.value = window.innerHeight;
  };

  onMounted(() => window.addEventListener("resize", update));
  onUnmounted(() => window.removeEventListener("resize", update));

  return { width, height };
}
```

## Vue 3 + Axios 请求封装（支持自动携带 token、错误统一处理）

### 答题话术：

> 在 Vue3 项目中我使用 Axios 封装了请求逻辑，配合拦截器统一处理 token 注入、错误提示、登录失效跳转等逻辑，提高了项目的可维护性。

### 核心代码结构：

```ts
// utils/http.ts
import axios from "axios";
import { useUserStore } from "@/stores/user";

const http = axios.create({
  baseURL: "/api",
  timeout: 10000,
});

http.interceptors.request.use((config) => {
  const store = useUserStore();
  if (store.token) {
    config.headers.Authorization = `Bearer ${store.token}`;
  }
  return config;
});

http.interceptors.response.use(
  (res) => res.data,
  (err) => {
    const status = err.response?.status;
    if (status === 401) {
      const store = useUserStore();
      store.setToken("");
      location.href = "/login";
    }
    ElMessage.error(err.response?.data?.message || "请求失败");
    return Promise.reject(err);
  },
);

export default http;
```

## 权限控制（菜单权限 + 路由权限）

### 答题话术：

项目中我结合后端返回的角色权限，动态生成菜单树，并在 Vue Router 中配置路由守卫，实现路由权限拦截和跳转控制。

🚧 实现要点：
• 登录后获取权限列表（按钮/路由级别）
• 菜单渲染通过 v-if 判断权限码
• 全局前置守卫 router.beforeEach 拦截未授权访问

### 核心代码结构：

```ts
// router/permission.ts
router.beforeEach(async (to, from, next) => {
  const store = useUserStore();
  if (!store.token && to.path !== "/login") {
    return next("/login");
  }

  if (to.meta.permission && !store.permissions.includes(to.meta.permission)) {
    return next("/403");
  }

  next();
});
```

## Vue3 表单验证优化（异步校验 + 条件校验）

### 答题话术：

> 表单中包含手机号、验证码、异步校验用户名是否存在、条件必填等逻辑，使用 async-validator 或 el-form 动态设置 rules。

### 核心代码结构：

```ts
const rules = reactive({
  username: [
    { required: true, message: "请输入用户名", trigger: "blur" },
    {
      validator: async (rule, value, callback) => {
        const exists = await checkUsername(value);
        if (exists) return callback(new Error("用户名已存在"));
        callback();
      },
      trigger: "blur",
    },
  ],
  phone: [{ required: true, message: "请输入手机号" }],
});
```
