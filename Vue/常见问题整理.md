## Vue3 和 Vue2 的核心区别？

1. 响应式系统实现不同

- `vue2` 使用 `object.defineProerty`,只能劫持已有属性,需手动深度监听(如数组)
- `vue3` 使用 `proxy` 可动态拦截属性添加删除,支持深层次嵌套结构,解决了 Vue2 中属性新增/删除监听不到的问题

2. 新增 Compostion API (组合式 API)

   - `vue2`使用 data(),methods,computed,wathch 等分散配置
   - `vue3`引入 seetup()函数,允许将相关逻辑聚合组织;更易于逻辑复用

3. 生命周期变化
   | Vue2 | vue3 |
   | ------------- | ----------------- |
   | created | setup() |
   | moutend | onMoutend() |
   | beforeDestroy | onBeforeUnmount() |
4. 模板编译和指令处理变化

   - v-if 和 v-for 优先级不同
     - `vue2`:v-for 优先于 v-if
     - `vue3 `:v-if 优先,避免无意义的循环
   - 新增〈script setup>语法糖,减少模板代码冗余

5. 性能优化
   - 默认支持`Tree-shaking`,体积更小
   - 更快的渲染机制(compiler 优化+Proxy)
   - 更好的 TypeScript 支持

> **答题话术**
> “Vue3 的最大变化在于底层响应式由 Object.defineProperty 改为 Proxy，解决了 Vue2 中属性新增/删除-监听不到的问题。同时，它引入了 Composition API，将逻辑更集中管理，更利于复用与类型推导。生命周期也发生变化，统一在 setup() 中调用 onMounted 等函数。我在项目中已经完成从 Vue2 向 Vue3 的升级，整体代码维护性和性能都有显著提升。”

### setup()中为什么不能使用 this?

- `setup()`在整个生命周期中优先级最高,在**组件实例创建之前执行的**，此时组件实例（即 this）尚未被完全初始化;
- `setup()`用于逻辑组织和组合的函数,所有的数据、props、methods 都通过函数参数解构或返回值暴露，**不再依赖 this 上的绑定**。

> **答题话术**
> “因为 setup() 是在组件实例创建之前执行的，因此此时还没有 this 可用。Vue3 推崇函数式逻辑组合方式，因此不再依赖 this，而是通过参数解构和返回对象来使用 props、emit 和响应式数据。这也是 Composition API 更具逻辑复用性和类型推导优势的重要体现。

## Vue2 和 Vue3 响应式的区别

### Vue2(object.defineProerty)

- 遍历递归对象,对每个属性单独设置` getter``setter `,性能开销较大;
- **无法动态监听属性变化(增删)**,对象属性变化时不会触发视图更新，需通过 `Vue.set` 或 `Vue.delete` **手动处理**;
- 无法直接监听数组索引的修改（如 `arr[0] = 1` ）和 `length` 变化;
- 只能支持代理普通对象和数组,不支持 `Map`、`Set` 等复杂数据结构。

### Vue3(Proxy)

- `Proxy` 可以直接代理整个对象，因此可以监听属性的**动态增删**，不再需要手动操作。
- 能够直接监听数组索引的修改（如 `arr[0] = 1` ）以及 `length` 变化。
- 采用懒代理模式,只有在访问属性时才会递归代理子对象,避免了递归遍历的性能开销。
- 支持更多数据结构,除了普通对象数组,`Proxy`还可以代理 `Map`、`Set` 等复杂数据结构。

## Composition API 相比 Options API 有哪些优势？

1. 逻辑聚合更清晰、更易于维护
   - 引入了`setup()`,可按功能组合代码(比如将表单逻辑集中在一个 `composable` 函数中)
   - 更适合大型项目的模块化
2. 响应式系统更灵活
   - `Composition API` 使用 `Vue3` 新的响应式系统（基于 `Proxy）`，,搭配 `ref` 和 `reactive` 能实现更精准的响应控制。
   - 可按需使用响应式变量，不再局限于 `data` 对象
   - 可以创建响应式函数和模块（如 `composable` `hooks`）
   - 支持逻辑抽离，不依赖 `this`
3. 生命周期更灵活,可重用性更强
   - `Vue3` 生命周期函数（如 `onMounted`, `onUnmounted`）可以在任何自定义函数中使用，支持复用逻辑中注册生命周期
4. 支持逻辑复用的函数式设计
   - `Composition API` 支持通过“composable”封装业务逻辑（如 useForm, useFetch），实现高度复用和测试友好
5. 更好的支持 TypeScript
   - `Composition API` 在类型推导、IDE 支持方面比 `Options API` 更友好

> **答题话术**
> “`Composition API` 更适合组织复杂组件逻辑，通过函数式组合实现代码聚合、逻辑复用，更利于维护和测试。同时搭配
> `Proxy` 响应系统与生命周期函数，可以让逻辑抽离到 composable 中，是真正面向模块化和大型应用的 API 设计。”

## Diff 算法

### 实现过程

> 通过对比前后两个虚拟 DOM 树,找出变化最小的集合,并以最优策略更新真实 DOM。

1. **同层比较**
   - Vue 默认只在同一层级进行节点对比，提升性能。
2. **核心对比策略**
   - 首尾双指针遍历(Head-to-Tail 比较)
   - 根据 key 快速定位变化位置
   - 移动/删除/新增节点操作精准控制
3. **patch 函数执行过程**
   - 判断节点类型是否相同->不同则替换
   - 判断 props 是否变化->做 attr 更新
   - 判断 children：
     - 文本 → 替换
     - 多子节点 → 调用 patchKeyedChildren 进行 Diff

### Vue3 Diff 算法 对比 Vue2 Diff 算法做了哪些优化

- Vue3 支持 Fragment、多根节点，因此 Diff 逻辑更灵活
- 当有 key 时，计算 最长递增子序列 以减少 DOM 移动次数（最少移动 = 保持顺序的最长子序列）
- Vue3 在模板编译阶段标记出哪些节点是静态的（patchFlag），运行时只更新动态部分
- 对静态 vnode 只创建一次，减少重复比较和创建过程

> 面试答题话术
> "Vue 的 Diff 算法是比较新旧 DOM,定位最小变化范围。`Vue2` 使用**双端对比方式**，性能还可以，但在长列表处理、节点移动上仍有优化空间。`Vue3` 引入了**最长递增子序列算法**，尽量减少 DOM 操作次数，同时利用模板编译时的静态提升（patchFlag + hoistStatic）标记静态内容，仅更新有变化的部分，极大提升了渲染性能。"

### Vue 和 React Diff 算法对比

#### 相同点

1. **使用虚拟 DOM:** 都通过构建 Virtual DOM 进行状态变化对比，提高性能和抽象能力
2. **基于同层比较:** 都默认不跨层级比较节点，以避免全量遍历
3. **依赖 key 提升属性:** 如果存在 key，会根据 key 快速定位节点变化
4. **目标是最小化 DOM 操作:** 尽可能少地执行增删改操作，提高渲染效率

#### 核心差异

| 维度               | Vue（特别是 Vue3）                           | React（特别是 Fiber 架构）                    |
| ------------------ | -------------------------------------------- | --------------------------------------------- |
| **Diff 方式**      | 基于传统递归 + 双端对比 + LIS 算法优化       | 基于 Fiber 架构，采用链表 + 分片时间切片遍历  |
| **性能优化点**     | 模板静态提升（Hoist）+ patchFlag 动态标记    | 使用 reconciliation 协议做异步任务切分        |
| **长列表更新策略** | 使用 key + 最长递增子序列（LIS）优化节点移动 | 使用 key 匹配，新旧 key 不一致则直接替换      |
| **渲染模式**       | 默认同步更新，可配合 Suspense 做异步         | 支持异步渲染（如 Concurrent Mode）            |
| **核心目标**       | 以最小 DOM 更新为目标                        | 支持高并发、任务打断/恢复（即响应优先级）     |
| **静态内容处理**   | 编译期分析，标记哪些节点是静态内容           | 没有静态内容优化，所有 JSX 都视为 render 函数 |

> “Vue 和 React 都使用虚拟 DOM 和同层比较策略，但 React 在 Fiber 架构下更关注更新调度和异步优先级，适合高并发渲染场景，而 Vue3 侧重于模板编译优化和静态内容提升，配合最长递增子序列算法（LIS）来最小化 DOM 更新，渲染效率更高。两者的设计理念和实现路径略有不同，Vue 更注重运行效率，React 更注重更新流管理。”

## Vue 组件的通讯方式有哪些？

组件之间的通讯通常分为父子组件通讯和跨组件通讯。要注意，vue3 组件的通讯方式和 vue2 有一定的区别。

| 方式                          | 适用场景            | 实现方式                                                    | 性能考虑 |
| ----------------------------- | ------------------- | ----------------------------------------------------------- | -------- |
| props / emit                  | 父子组件通信        | 父组件传递数据，子组件监听事件                              | 简单     |
| ref                           | 跨组件访问 DOM 元素 | 在父组件中使用 `ref` 引用子组件实例                         | 简单     |
| provide / inject              | 跨组件共享数据      | 在父组件中使用 `provide` 提供数据，子组件使用 `inject` 注入 | 简单     |
| 自定义事件                    | 跨组件通信          | 自定义事件，通过 `$emit` 触发，`$on` 监听                   | 简单     |
| Vuex                          | 全局状态管理        | 集中管理应用状态                                            | 中等     |
| Pinia                         | 全局状态管理        | 集中管理应用状态                                            | 中等     |
| 第三方库（如 mitt、eventbus） | 全局事件总线        | 发布订阅模式，解耦组件通信                                  | 中等     |
| 自定义 Hook                   | 逻辑复用            | 封装可复用的逻辑，如 `useXxx`                               | 中等     |
| 上下文对象                    | 跨组件共享数据      | 使用 `provide` 和 `inject` 实现                             | 中等     |
| 全局对象                      | 全局共享数据        | 使用全局对象（如 `window`）                                 | 简单     |
| 自定义事件总线                | 全局事件总线        | 封装事件总线，解耦组件通信                                  | 中等     |

## 组件生命周期

Vue 组件的生命周期是指组件从创建到销毁的整个过程，包括组件的初始化、渲染、更新和销毁等阶段。在 Vue2 和 Vue3 中，组件的生命周期有一些区别。

### Vue2

- **创建阶段**

1️⃣ **beforeCreate**：组件实例刚被创建，数据观测和事件/监听器设置之前。此时无法访问 `data` 、 `computed` 和 `methods` 等。
2️⃣ **created**：组件实例已创建，数据观测、事件/监听器设置完成，此时可以访问 `data` 、 `computed` 和 `methods` 等，通常用于数据初始化。

- **挂载阶段**

3️⃣ **beforeMount**：在挂载开始之前，模板已编译， `el` 和 `template` 已经确定，但尚未渲染。
4️⃣ **mounted**：组件实例挂载到 DOM 上之后，此时可以访问和操作 DOM。

- **更新阶段**

5️⃣ **beforeUpdate**：数据发生变化，DOM 尚未更新。可以在这里做一些数据处理，避免不必要的渲染。
6️⃣ **updated**：数据变化，DOM 更新后调用。此时组件的 DOM 已经更新，可以访问和操作新的 DOM。

- **销毁阶段**

7️⃣ **beforeDestroy**：组件实例销毁之前。可以在此阶段进行清理工作，例如移除事件监听器、定时器等。
8️⃣ **destroyed**：组件实例销毁之后。此时，所有的事件监听器和子组件已被销毁。

### Vue3

- **创建阶段**

1️⃣ **onBeforeMount**：等效于 Vue 2 中的 `beforeMount` ，在组件挂载之前调用。
2️⃣ **onMounted**：等效于 Vue 2 中的 `mounted` ，在组件挂载之后调用。

- **更新阶段**

3️⃣ **onBeforeUpdate**：等效于 Vue 2 中的 `beforeUpdate` ，在数据更新之前调用。
4️⃣ **onUpdated**：等效于 Vue 2 中的 `updated` ，在数据更新并渲染之后调用。

- **销毁阶段**

5️⃣ **onBeforeUnmount**：等效于 Vue 2 中的 `beforeDestroy` ，在组件卸载前调用。
6️⃣ **onUnmounted**：等效于 Vue 2 中的 `destroyed` ，在组件卸载后调用。

tip setup 与生命周期

setup 作为 Vue3 的 Composition API 的一部分, 其内部函数的执行时机早于 Mounted 钩子。

```vue{7}
<script setup>
  import { ref, onMounted } from 'vue';
  console.log("setup");
  onMounted(() => {
  console.log('onMounted');
  });
  // 执行结果:setup onMounted
</script>

```

## Vue 组件在哪个生命周期发送 ajax 请求？

在 Vue 中，接口请求一般放在 `created` 或 `mounted` 生命周期钩子中。

**created 钩子**

- 优点：
  ✅ **更快获取数据**：能尽早获取服务端数据，减少页面加载时间。
  ✅ **SSR 支持**：支持服务器端渲染（SSR），在 SSR 环境中不会受到限制。

- 缺点
  ❌ UI 未渲染时发起请求：如果需要操作 DOM 或渲染数据，可能导致闪屏问题

**mounted 钩子**

- 优点：
  ✅ **DOM 可用**：适合需要操作 DOM 或渲染数据后再发起请求的情况，避免闪屏。

- 缺点
  ❌ **请求延迟**：数据请求会稍微延迟，增加页面加载时间。
  ❌ **SSR 不支持**：`mounted` 只在客户端执行，不适用于 SSR 环境。

## v-show 和 v-if 的区别

- **渲染方式：**
  💡v-if：条件为 true 时才会渲染元素，条件为 false 时销毁元素。
  💡v-show：始终渲染元素，只是通过 CSS 控制 `display 属性`来显示或隐藏。
- **适用场景：**
  💡v-if：适用于条件变化不频繁的场景。
  💡v-show：适用于条件变化频繁的场景。

## 为何 v-if 和 v-for 不能一起使用？

`v-if` 和 `v-for` 不能直接一起使用的原因，主要是因为它们在 **解析优先级** 和 **逻辑处理** 上存在冲突。

由于`v-for` 的解析优先级高于 `v-if`，同时使用 v-if 和 v-for，Vue 首先会循环创建所有 dom 元素，然后根据条件来判断是否渲染每个元素，这种方式可能导致 Vue 进行大量的 DOM 操作，性能较差。其次，`v-for` 会为每个循环项创建一个新的作用域，而 `v-if` 的条件如果依赖于这个作用域内的数据，可能导致判断逻辑异常。

为避免上述问题，vue 官方推荐我们将 `v-if` 放到 `v-for` 外层，或者将 `v-if` 放置到 `v-for` 内部的单个节点上。

```js
<div v-if="show">
  <div v-for="item in list" :key="item.id">{{ item.name }}</div>
</div>
```

## computed 和 watch 有什么区别

**computed**用于计算基于响应式数据的值，并缓存结果:

```vue
<template>
  <div>
    <p>原始值：{{ count }}</p>
    <p>计算后的数值：{{ doubledCount }}</p>
  </div>
</template>

<script setup>
import { ref, computed } from "vue";

const count = ref(2);

// 计算属性
const doubledCount = computed(() => count.value * 2);
</script>
```

**watch**用于监听数据变化并执行副作用操作

```vue
<template>
  <div>
    <p>原始数值：{{ count }}</p>
    <button @click="count++">增加数值</button>
  </div>
</template>

<script setup>
import { ref, watch } from "vue";

const count = ref(0);

// 监听器
watch(
  count,
  (newVal, oldVal) => {
    console.log(`数值从 ${oldVal} 变为 ${newVal}`);
  },
  // 立即生效immdiate
  //深度监听deep
);
</script>
```

| 特性         | `computed`                                                   | `watch`                                                  |
| ------------ | ------------------------------------------------------------ | -------------------------------------------------------- |
| **用途**     | 用于计算基于响应式数据的值，并缓存结果                       | 用于监听数据变化并执行副作用操作                         |
| **返回值**   | 返回计算结果                                                 | 不返回值，执行副作用                                     |
| **缓存机制** | 只有在访问时才会计算，会缓存计算结果，仅当依赖变化时重新计算 | 数据变化时立即执行回调，不缓存，每次数据变化都会触发回调 |
| **适用场景** | 计算派生数据，避免不必要的重复计算                           | 执行异步操作、处理副作用操作，如 API 请求                |
| **性能**     | 性能较好，避免重复计算                                       | 每次数据变化时都会执行回调函数                           |

## watch 和 watchEffect 的区别

### 依赖追踪方式

`watch` ：需要**显式声明依赖，**监听指定的数据源\*\*；可以监听多个数据源或进行深度监听。

```js
import { watch, reactive } from "vue";
const state = reactive({
  count: 0,
});
watch(
  () => state.count, // 显式声明监听的依赖
  (newCount, oldCount) => {
    console.log(`新值 ${newCount} 老值 ${oldCount}`);
  },
);
```

`watchEffect` ：会自动追踪 **作用域内所有的响应式依赖**，不需要显式声明依赖。

```js
import { watchEffect, reactive } from "vue";
const state = reactive({
  count: 0,
});
watchEffect(() => {
  console.log(`Count 变化了: ${state.count}`); // 自动追踪 `state.count`
});
```

### 执行时机

`watch` ：在监听的响应式数据变化后立即执行。

`watchEffect` ：在 **组件挂载时** 执行一次副作用，并在 **依赖发生变化时** 再次执行。

### 适用场景

`watch` ：适用于 **监听特定数据** 变化并执行副作用的场景，如 API 请求、保存操作等。适合需要 **访问新值和旧值** 进行比较的场景。

`watchEffect` ：不需要访问旧值，适用于 **自动追踪多个响应式依赖** 的副作用，如渲染、自动保存等。

## 插槽(Slot)

slot 是 Vue 中的一种用于 组件内容分发 的机制。它允许父组件向子组件插入内容，从而使组件更加灵活和可复用。

在 Vue 中，插槽的使用方式可以分为四种：**默认插槽**、**具名插槽**、**条件插槽**和**作用域插槽**。

### 默认插槽

默认插槽是最简单的插槽形式，它允许我们将组件的内容传递到组件内部的一个占位符中。

子组件 `MyComponent.vue`

```vue
<template>
  <div>
    <p>我是子组件的标题</p>
    <slot></slot>
  </div>
</template>
```

父组件

```vue
<template>
  <MyComponent>
    <p>这是插槽内容，由父组件传入</p>
  </MyComponent>
</template>
```

输出结果：

```html
<div>
  <p>我是子组件的标题</p>
  <p>这是插槽内容，由父组件传入</p>
</div>
```

### 具名插槽

当子组件需要多个插槽时，可以为插槽命名，并由父组件指定内容放置到哪个插槽。

子组件 `MyComponent.vue`

```vue
<template>
  <slot name="header">默认标题</slot>
  <slot>默认内容</slot>
  <slot name="footer">默认页脚</slot>
</template>
```

父组件

```vue
<template>
  <MyComponent>
    <template v-slot:header>
      <h1>我来组成头部</h1>
    </template>
    <!-- 隐式的默认插槽 -->
    <p>我来组成身体</p>
    <template v-slot:footer>
      <p>我来组成尾部</p>
    </template>
  </MyComponent>
</template>
```

输出结果：

```html
<div>
  <h1>我来组成头部</h1>
  <p>我来组成身体</p>
  <p>我来组成尾部</p>
</div>
```

> `v-slot` 有对应的简写 `#` ，因此 `<template v-slot:header>` 可以简写为 `<template #header>` 。其意思就是“将这部分模板片段传入子组件的 header 插槽中”。

### 条件插槽

我们可以根据插槽是否存在来渲染某些内容:

子组件 `MyComponent.vue`

```vue
<template>
  <div class="card">
    <div v-if="$slots.header" class="card-header">
      <slot name="header" />
    </div>

    <div v-if="$slots.default" class="card-content">
      <slot />
    </div>

    <div v-if="$slots.footer" class="card-footer">
      <slot name="footer" />
    </div>
  </div>
</template>
```

### 作用域插槽

作用域插槽可以让子组件在渲染时将一部分数据提供给插槽，从而实现父组件的插槽访问到子组件的状态。

子组件 `MyComponent.vue`

```vue
<template>
  <ul>
    <!-- 定义作用域插槽，并将 items 数据传递给父组件 -->
    <slot :items="items"></slot>
  </ul>
</template>

<script setup>
import { ref } from "vue";

// 定义数据 items
const items = ref(["华为", "小米", "苹果"]);
</script>
```

```vue
<template>
  <MyComponent>
    <!-- 使用作用域插槽，接收子组件传递的 items 数据 -->
    <template #default="{ items }">
      <li v-for="(item, index) in items" :key="index">
        {{ item }}
      </li>
    </template>
  </MyComponent>
</template>

<script setup>
import MyComponent from "./MyComponent.vue";
</script>
```

输出结果：

```html
<ul>
  <li>华为</li>
  <li>小米</li>
  <li>苹果</li>
</ul>
```

> tip 应用场景
> 💡 灵活的组件内容插入：
> 插槽允许我我们将内容插入组件中，而无需修改子组件内部逻辑，极大提高了组件的灵活性。
> 💡 构建通用组件：
> 比如开发卡片、模态框、列表等组件，使用插槽可以轻松实现内容的自定义。模态框组件可通过插槽自定义标题、正文和按钮。
>
> 💡 减少重复代码：
> 通过插槽，将公共逻辑封装到子组件中，而在父组件中只需插入变化的内容。
